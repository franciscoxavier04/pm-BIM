## What are ARIA Live Regions?
ARIA Live Regions are a crucial accessibility feature that allow screen readers to announce dynamic content updates without requiring user focus changes.

### ARIA Live Attributes
ARIA Live Regions rely on specific attributes to control how updates are announced:
- `aria-live="polite"`: Announces updates when the user is idle.
- `aria-live="assertive"`: Announces updates immediately, interrupting the user.
- `aria-atomic="true"`: Ensures the entire content of the region is read when it changes.

## Implementing ARIA Live Regions in Primer
The Primer project provides a custom element (Web Component) to ease working with ARIA Live Regions.
We have decided to use a single global ARIA live region in base.html to ensure live regions are present in the DOM before updates occur. This approach is better than having multiple live regions because it ensures that announcements are delivered in a clear and consistent manner. By centralizing updates, we avoid potential conflicts between overlapping live regions and provide a more seamless experience for screen reader users.

### Live Region in `base.html`
```html
<live-region>
  <div id="polite" aria-live="polite" aria-atomic="true" class="hidden-for-sighted"></div>
  <div id="assertive" aria-live="assertive" aria-atomic="true" class="hidden-for-sighted"></div>
</live-region>
```

The `@primer/live-region-element` package provides methods to trigger announcements programmatically:

```ts
import { announce } from '@primer/live-region-element';

announce('Example polite message', { politeness: 'polite' });
```

### Using Turbo Streams to Trigger ARIA Live Updates
To use it in a Rails Turbo response, and send updates to the screen reader after any action, we created a new Turbo stream component that triggers an ARIA action:

```ruby
OpTurbo::StreamComponent.new(action: :aria, message: "Form submission successful!", type: "polite", role: "status", target: nil)
```

- This creates a **Turbo Stream update** with:
  - `action: :aria` → Calls the `aria` action defined in `aria.stream.action.ts`
  - `message: "Form submission successful!"` → The text announced by the screen reader
  - `type: "polite"` → Ensures the message is read when the user is idle
  - `role: "status"` → Helps screen readers recognize this as a status update
  - `target: "nil"` → Ensures the update isn't inserted into the DOM but is handled as an announcement

### How to Trigger an ARIA Update from the Controller
You can trigger a screen reader announcement from your Rails controller by calling the `render_aria_update_message` helper, which is already provided:

```ruby
render_aria_update_message(
  message: I18n.t("work_package_relations_tab.relations.create_child_aria_live_message"),
  type: "polite"
)
```

This helper internally renders a Turbo Stream using the aria action to announce the message via ARIA live regions.
For reference only — you do not need to define this yourself.
Here is the internal implementation of `render_aria_update_message`:

```ruby
    def render_aria_update_message(message:, type:, role: "alert")
      turbo_streams << OpTurbo::StreamComponent.new(action: :aria, message:, type:, role:, target: nil).render_in(view_context)
    end
```

### How to Trigger an ARIA Update from a Turbo Frame
If you're using a Turbo Frame and want to announce dynamic content changes to screen readers, you can embed a Turbo Stream using the `aria` action directly inside the frame.

```erb
<%= content_tag("turbo-frame", id: "frame-id") do %>
....
  <%= render OpTurbo::StreamComponent.new(
    action: :aria,
    message: "Update!!",
    type: "polite",
    target: nil
  ) %>
<% end %>

```

### How ARIA Live Messages Are Delivered via Turbo Streams
The `registerAriaStreamAction` method defines a custom Turbo Stream action called `aria`. When triggered, it announces a message (using ARIA live regions) to screen readers, with a tone of either `"polite"` or `"assertive"`, depending on the `type` attribute in the stream element.

```ts
import { StreamActions, StreamElement } from '@hotwired/turbo';
import { announce } from '@primer/live-region-element';

export function registerAriaStreamAction() {
  StreamActions.aria = function ariaStreamAction(this:StreamElement) {
      const message = this.getAttribute('message') ?? '';
      const type = this.getAttribute('type') ?? 'polite';
      if (type === 'assertive') {
        void announce(message, {
          politeness: 'assertive',
        });
      } else {
        void announce(message, {
          politeness: 'polite',
          delayMs: 5000,
        });
      }
  };
}
```

## Live Regions in Dialogs and Modals
There is an important exception to our use of the global ARIA live region in base.html.

When a modal or dialog is open, screen readers often restrict focus and reading context to the content inside the dialog. In this case, ARIA live regions outside the dialog (such as those defined in base.html) become inaccessible to the screen reader.

To ensure that announcements are still read aloud in this situation, we should include a live-region component within the dialog itself, like what we have implemented for primerized date picker.

```erb
  <live-region>
    <div id="assertive" aria-live="assertive" aria-atomic="true" class="hidden-for-sighted"></div>
  </live-region>
  <%= render OpTurbo::StreamComponent.new(action: :aria, message: "Date picker is updated.", type: "assertive", target: "nil") %>
```
